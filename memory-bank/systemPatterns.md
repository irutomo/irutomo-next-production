# システムパターン - irutomo222レストラン予約システム

## アーキテクチャ概要

irutomo222レストラン予約システムは、Next.js 15.2を基盤としたモダンなWebアプリケーションです。App Routerモデルを採用し、React Server Componentsとクライアントコンポーネントを効果的に組み合わせてパフォーマンスとユーザー体験を最適化しています。

### アーキテクチャモデル
- **フレームワーク**: Next.js 15.2, React 19
- **UI**: React Server Components, クライアントコンポーネント
- **データ層**: Supabase (PostgreSQL)
- **外部サービス**: PayPal (決済), Channel.io (サポート)

## フロントエンドパターン

### ディレクトリ構造とファイル規約
1. **App Routerディレクトリ構造**
   - `app/` - App Routerのルートディレクトリ
   - `app/layout.tsx` - ルートレイアウト
   - `app/page.tsx` - ホームページ
   - `app/(routes)/[...]` - 各種ルート
   - `app/api/[...]` - APIルート
   - `app/[locale]/[...]` - 多言語サポート
   - `app/reviews/` - レビュー一覧ページ
   - `app/write-review/` - レビュー投稿ページ
   - `app/service/` - サービス紹介ページ
   - `app/restaurants/` - レストラン一覧・詳細ページ
   - `app/reservation/` - 予約管理ページ

2. **コンポーネント構造**
   - `components/` - 共通コンポーネント
   - `components/ui/` - 基本UI要素（Shadcn UI）
   - `components/[feature]/` - 機能別コンポーネント
   - `lib/` - ユーティリティ関数
   - `hooks/` - カスタムフック
   - `contexts/` - コンテキスト

3. **命名規約**
   - ファイル名: kebab-case (例: `reservation-form.tsx`)
   - コンポーネント名: PascalCase (例: `ReservationForm`)
   - フック名: camelCase + use接頭辞 (例: `useReservation`)
   - ユーティリティ関数: camelCase (例: `formatCurrency`)

### コンポーネント設計パターン
1. **Server/Client分離パターン**
   - `page.tsx` (Server Component) - データフェッチング、SEO、初期レンダリング
   - `*.client.tsx` - インタラクティブなクライアント側機能
   - `.tsx` (デフォルトServer Component) - UI表示、データレンダリング
   - `use client` - クライアントコンポーネントのマーカー

2. **Atomicデザイン（部分的に採用）**
   - `ui/button.tsx`, `ui/input.tsx` - 基本要素
   - `ui/form.tsx`, `ui/card.tsx` - 複合要素
   - `components/header.tsx`, `components/footer.tsx` - 複雑なコンポーネント
   - `app/[route]/layout.tsx` - ページレイアウト

3. **React Server Components (RSC) パターン**
   - データフェッチングを含むコンポーネント
   - SEO関連機能と静的コンテンツレンダリング
   - プロップドリリングの回避
   - サーバーサイド限定のAPIやデータへのアクセス

4. **クライアントコンポーネントパターン**
   - ユーザーインタラクション（フォーム、ボタンなど）
   - ステート管理が必要なUI要素
   - ブラウザAPIを使用する機能
   - useEffectやEventHandlerを必要とする要素

5. **パラレルルートとインターセプトルート**
   - 複数のビューを同時に表示するパラレルルート
   - モーダルやスライドオーバーのためのインターセプトルート
   - ナビゲーションの中断なしのUI表示
   - ログインモーダルとレビュー詳細モーダルに実装中

6. **セクションコンポーネントパターン**
   - ページをセクション別コンポーネントに分割
   - 例: `HeroSection`, `FeaturesSection`, `ReviewsSection`
   - 再利用可能で独立したセクション設計
   - 読み込み順序の最適化

### データフェッチングパターン
1. **Server Componentsでのデータフェッチ**
   - コンポーネント内での直接fetch
   - APIハンドラー関数のインポート
   - データベースクライアントの直接利用
   - 並列データフェッチ

2. **TanStack Query (クライアント側)**
   - リアルタイムデータの取得と更新
   - キャッシュ管理と再検証
   - 楽観的UI更新
   - エラー処理とリトライ

3. **サーバーアクション**
   - クライアントからサーバー関数を直接呼び出し
   - フォーム処理とデータミューテーション
   - 楽観的更新とサーバー検証
   - TypeScript型安全性の維持
   - フォーム検証とエラーハンドリング

### レンダリングとパフォーマンスパターン
1. **ストリーミングとSuspense**
   - 段階的UIローディング
   - コンテンツストリーミング
   - ローディング状態のカスタマイズ
   - Suspenseバウンダリの効果的な配置

2. **プログレッシブエンハンスメント**
   - 基本機能のサーバーレンダリング
   - JavaScript無効時の基本機能維持
   - クライアント側での機能強化

3. **メタデータの最適化**
   - 静的メタデータとdynamic generateMetadata
   - ストリーミングメタデータによるパフォーマンス向上
   - SEO対応のメタデータ自動生成
   - 全ページでの実装進行中

4. **画像最適化**
   - next/imageによる自動最適化
   - WebPフォーマットの利用
   - 遅延ロードと優先順位付け
   - 適切なサイズと品質の選択

5. **部分的プリレンダリング (PPR)**
   - 静的部分の事前レンダリング
   - 動的部分のストリーミング
   - キャッシュ戦略の最適化
   - 導入評価中

## バックエンドパターン

### APIルート設計
1. **ルートハンドラー**
   - `app/api/[...]/route.ts` - REST API実装
   - HTTPメソッド対応関数 (GET, POST, PUT, DELETE)
   - Next.js Response/Request APIの活用
   - エラーハンドリングとステータスコード

2. **バージョニング戦略**
   - `/api/v1/[リソース]` - API版数管理
   - 下位互換性の維持
   - 非推奨APIの段階的廃止

3. **ミドルウェア適用**
   - `middleware.ts` - グローバルミドルウェア
   - シンプルな認証チェックによるルート保護
   - レート制限とスロットリング
   - リクエスト/レスポンス変換

### 認証パターン
1. **シンプルなセッション管理**
   - ✅ Cookieベースのセッション管理
   - ✅ Next.js App Routerとの統合
   - ✅ ミドルウェアによる認証保護
   - ✅ セキュアなセッション保存

2. **Supabase連携**
   - ✅ データアクセス制御
   - ✅ Server Actionsでの認証フロー
   - ✅ 型安全なセッション管理
   - ✅ Supabase RLS (Row Level Security)
   - ✅ クライアントサイドでのデータアクセス制御

3. **認可**
   - ✅ ロールベースアクセス制御
   - ✅ ポリシーベースのデータアクセス
   - ✅ 機能フラグによる機能の有効化/無効化
   - ✅ ミドルウェアによるルート保護

### エラーハンドリングパターン
1. **Next.js エラーハンドリング**
   - `error.tsx` - ルート別エラーUI
   - `not-found.tsx` - 404カスタム表示
   - `global-error.tsx` - グローバルエラー
   - React Error Boundaryの活用

2. **カスタムエラークラス**
   - ✅ `ApiError`, `ValidationError`, `AuthenticationError`など
   - ✅ エラータイプ、コード、メッセージを含む
   - ✅ スタックトレース保持
   - ✅ 追加メタデータサポート

3. **Try/Catchとサーバーアクション**
   - ✅ サーバーアクション内でのエラーキャプチャ
   - ✅ クライアント側へのエラー伝播
   - ✅ 自動リトライメカニズム
   - ✅ タイムアウト処理
   - ✅ エラーメッセージのローカライズ

## データベース設計パターン

### スキーマ設計
1. **正規化**
   - 3NF（第三正規形）までのデータ正規化
   - 外部キー制約
   - カスケード更新/削除

2. **インデックス戦略**
   - 検索/フィルタリングフィールドへのインデックス付与
   - 複合インデックス
   - パフォーマンス最適化

3. **テーブル設計パターン**
   - ユーザー関連テーブル
     - `users` - ユーザー基本情報
     - `profiles` - 拡張プロフィール情報
     - `auth_providers` - 認証プロバイダー情報
   - レストラン関連テーブル
     - `restaurants` - レストラン基本情報
     - `restaurant_hours` - 営業時間
     - `tables` - テーブル情報
     - `categories` - カテゴリ
   - 予約関連テーブル
     - `reservations` - 予約情報
     - `reservation_statuses` - 予約ステータス
     - `time_slots` - 時間枠
   - レビュー関連テーブル
     - `reviews` - レビュー基本情報
     - `review_images` - レビュー画像
     - `review_tags` - レビュータグ
     - `review_replies` - レビュー返信
   - 支払い関連テーブル
     - `payments` - 支払い情報
     - `payment_methods` - 支払い方法
     - `transactions` - 取引履歴

### セキュリティパターン
1. **Supabase行レベルセキュリティ（RLS）**
   - 全テーブルにRLSポリシーを設定し、認証されたユーザーのみが自分のデータにアクセス可能に
   - 予約テーブルでは、予約したユーザーと対象レストランオーナーのみが閲覧可能なポリシーを実装
   - 一部のサーバーサイド処理ではRLSポリシーをバイパスする必要があるため、サービスロールキーを使用

2. **サービスロールの利用**
   - `SUPABASE_SERVICE_ROLE_KEY`環境変数を利用して安全にキーを管理
   - サーバーサイドの特権操作（支払い確認後のデータベース更新など）にのみ使用
   - サービスロールクライアントインスタンスはRoute HandlersやServer Actionsでのみ作成し、クライアントサイドには渡さない

3. **監査**
   - データ変更履歴
   - ユーザーアクション記録
   - セキュリティ監査証跡

## UI/UXパターン

### レスポンシブデザイン
1. **モバイルファーストアプローチ**
   - 最小画面サイズからのデザイン
   - Progressive Enhancement
   - フレキシブルグリッドシステム

2. **コンポーネント適応**
   - スクリーンサイズに応じたレイアウト変更
   - コンテンツの優先順位付け
   - インタラクションの最適化

3. **ナビゲーション**
   - モバイル用ハンバーガーメニュー
   - デスクトップ用水平ナビ
   - コンテキスト認識型ナビゲーション

### フォーム設計
1. **段階的フォーム**
   - 複雑なフォームのステップ分割
   - 進行状況表示
   - 保存と再開機能

2. **バリデーション**
   - クライアント側即時検証
   - サーバー側の完全検証
   - エラーフィードバック

3. **アクセシビリティ**
   - スクリーンリーダー対応
   - キーボードナビゲーション
   - フォーカス管理

### アニメーションとトランジション
1. **UI状態トランジション**
   - ローディング状態
   - エラー状態
   - 成功状態

2. **ページトランジション**
   - Framer Motionによるアニメーション
   - Next.js App Routerとの統合
   - Viewトランジション

3. **マイクロインタラクション**
   - ボタンのホバー/プレス状態
   - フォーム要素のフォーカス
   - 通知とアラート

## 国際化パターン

### 多言語対応
1. **翻訳管理**
   - next-intlによる翻訳管理
   - 言語ファイルの構造化
   - 動的コンテンツの翻訳

2. **言語検出と設定**
   - ブラウザ言語検出
   - ユーザー言語設定
   - URLベースの言語指定

3. **方向対応**
   - 左から右へ (LTR) と右から左へ (RTL) のレイアウト
   - 方向性の自動検出
   - コンポーネントの方向対応

### 地域化
1. **日付と時間**
   - date-fnsによる地域対応
   - タイムゾーン処理
   - カレンダー形式

2. **数値と通貨**
   - 通貨記号と表示形式
   - 数値フォーマット
   - 小数点と桁区切り

3. **その他の地域設定**
   - 住所形式
   - 電話番号形式
   - 単位表示

## テストパターン

### ユニットテスト
1. **コンポーネントテスト**
   - Vitest + Testing Library
   - インタラクションテスト
   - スナップショットテスト

2. **関数とフックテスト**
   - 純粋関数のテスト
   - カスタムフックテスト
   - モックとスタブ

### 統合テスト
1. **機能フロー**
   - 複数コンポーネントにまたがるフロー
   - APIとのインテグレーション
   - データ処理パイプライン

2. **サーバーレンダリング**
   - Server Componentsのテスト
   - メタデータ生成のテスト
   - レスポンスストリーミングのテスト

### E2Eテスト
1. **ユーザージャーニー**
   - Playwrightによるフルフロー検証
   - マルチブラウザテスト
   - モバイル/デスクトップテスト

2. **パフォーマンステスト**
   - ロード時間測定
   - Core Web Vitalsの検証
   - リソース消費の測定

## デプロイメントパターン

### CI/CD
1. **自動化**
   - GitHub Actions
   - テスト自動化
   - デプロイ自動化

2. **環境分離**
   - 開発環境
   - テスト環境
   - ステージング環境
   - 本番環境

### インフラストラクチャ
1. **Vercelデプロイ**
   - Vercel統合
   - エッジネットワーク最適化
   - 自動スケーリング

2. **環境設定**
   - 環境変数管理
   - シークレット管理
   - リージョン設定

### モニタリングと解析
1. **パフォーマンス監視**
   - Vercel Analytics
   - Web Vitals測定
   - 異常検出

2. **エラー追跡**
   - ランタイムエラーのキャプチャ
   - エラー分析
   - ユーザーインパクト評価

3. **ユーザー分析**
   - ユーザーフローの追跡
   - コンバージョン分析
   - フィーチャーユセージ分析

## 今後の検討パターン

### AI/ML統合
1. **レコメンデーション**
   - ユーザーベースのレコメンデーション
   - コンテンツベースのレコメンデーション
   - ハイブリッドアプローチ

2. **検索最適化**
   - 意味検索
   - 自動補完
   - フィルタリング支援

3. **コンテンツモデレーション**
   - 不適切コンテンツの検出
   - スパム対策
   - 自動分類

### PWA機能
1. **オフライン対応**
   - Service Worker
   - キャッシュ戦略
   - バックグラウンド同期

2. **インストール可能性**
   - Web App Manifest
   - インストールプロンプト
   - ホーム画面統合

3. **プッシュ通知**
   - 通知権限管理
   - 通知カスタマイズ
   - アクション対応通知

## データアクセスパターン

### Supabase RLSとサービスロールキー
- 通常のクライアントアクセスでは、RLSポリシーに基づいたアクセス制御を実施
- 決済処理などの特殊なサーバーサイド操作では、サービスロールキーを使用してRLSをバイパス
- `SUPABASE_SERVICE_ROLE_KEY`環境変数で管理し、Server Actionsからのみアクセス可能
- RLSバイパスは必要最小限の操作（決済完了後のデータ保存など）に限定して使用

### エラーハンドリングパターン
- 決済処理エラーは詳細なログ出力とユーザーへの適切なフィードバックを提供 